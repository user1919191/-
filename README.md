# 项目架构
* 本项目使用Java开发,基于SpringBoot+LangChain4J框架。结合MySQL,Redis,RocketMQ,ES,RAG实现功能扩展和性能提升。
* 在本项目中实现了题目,题库的增删改查和分页查询。管理员可以增加修改删除题目题库关联并且通过AI生成题目题解。用户可以设置自己的用户名片和进行发帖操作,并且用户可以点赞和收藏帖子。用户可以签到,搜索题目,查看题目题解。本项目与LangChain4j结合,结合DashScope调用大模型,PgVector存储向量,RAG实现增强检索,实现多种模拟面试功能。
* 以下为项目架构图:
![无标题-2025-05-05-1146 3](https://github.com/user-attachments/assets/54449271-5443-437c-9a4e-ee60ed01508b)
* 以下为本项目的自纠错RAG架构图:
![无标题-2025-05-05-1146 5](https://github.com/user-attachments/assets/5d869f8c-03e7-4855-a23e-a65a1d5d003a)

# 具体实现
## 题目业务模块
1. 将题目的标签字段以String存储在数据库中,返回前端时将String转化为List<String>便于展示。
2. **使用BitMap优化用户签到功能**,实现更小的存储占用.通过位运算来定位签到情况,通过牺牲签到数据的可读性换取更优的存储性能。在将签到数据返回前端时,通过位运算将已签到的日期(在某年中的DayOfYear)封装为List返回给前端,可以直接展示。
3. 数据库数据采用**逻辑删除**,提升性能和数据可恢复性。
4. 在题目修改时,**通过Canal监听BinLog和同步ES解耦**。
5. 在题目删除时,通过将Caffeine的value设置为Null,**避免缓存击穿**。
6. 引入DeepSeek大模型实现题目题解的自动生成,并将Status设置为待审核,等待管理员审核通过才可见。编写精简的Prompt降低Token开销。
7. 分页时,使用查询记录返回下一页首ID,将ID作为查询条件**解决深分页问题**。
8. 对于Caffeine缓存实现缓存预热,并且通过Spring Schedule定时检测和清理Caffeine状态,记录命中率和占用率到日志文件。当命中率低时,**从HotKey同步热点数据**;当占用率高时,首先让Caffeine**自动清理本地缓存**,再次检测占用率,如果占用率依旧高,**手动通过LFU算法**,依据CurrentTotal*0.2**动态清理**冷数据释放空间。实现缓存高可用。
9. 使用Sentinel针对分页查询和单个题目查询进行限流,防治大量数据访问导致系统不可用。编写降级和限流方案,限流返回Null,降级查询缓存数据。提高系统可用性和稳定性。

### 对于BitMap做签到功能的技术选型
#### BitMap性能
* 在本项目中使用的是为每一个user的每年签到情况分配一个BitMap,因为每一天占用1Bit,全年365天大概占用46字节.100万用户就需要占用43.57MB,极大节省了内存占用。因为使用位运算节约了空间,所以带来了签到日期可读性的损失,也就不能直观的读取签到日期,要进行位运算来获取某天的签到情况。而且因为BitMap的特殊性,也不能直接将BitMap返回给前端,所以在业务层对BitMap进行了另外一层封装,将签到情况转化为List<Intiger>数组。
#### BitMap做签到统计的问题
##### 代码可读性变差
* 这是最直观的,但是**在可读性和存储性能间做出取舍,可读性可以通过业务层的逻辑解决**。
#####  稀疏的签到情况会浪费空间
* 在实现的时候也考虑到这个情况,也想过使用Set/keyValue + BitMap动态切换,混合存储。也对Redis Set和Redis键值存储进行了对比
* 相比于Redis Set: Set的内存占用情况:内存空间 = 12字节头部+ 2xN字节。当签到日期超过18天时,占用内存为48字节,超过BitMap的46字节。所以超过18天后,存储性能就不如BitMap。
* 相比于Redis键值存储: Value通过1字节的分隔符+3字节的DayOfYear拼接成字符串,当签到天数小于12天时,占用小于BitMap。但是阈值太小没有使用意义。
* **在动态切换中,要每次签到都要进行存储判断,增加了性能损耗,对于内存节约也提升不大,所以放弃混合存储方案,直接使用BitMap存储签到记录**。
##### 连续签到天数的计算要遍历
* 如果要对用户的连续签到天数进行统计,需要从当天bit位开始,向前遍历,找到最大连续长度。性能较低,所以对于最大连续存储,我才用额外**使用一个记录最大签到日期的键值对来存储**,在每次签到时,先判断当前bit位的上一位是否为1,是则自增1;不是则设为1。这样就**将最大连续天数统计和BitMap签到位图充分解耦,提高了查询最大连续签到日期的性能**。

### 对于缓存一致性的方案选型
* 以下为本项目Canal+MQ的流程图:
![无标题-2025-05-05-1146 7](https://github.com/user-attachments/assets/717fde80-0945-433d-b137-ce50dddcdbfb)
#### 选择Canal+MQ保证缓存一致性的原因
* 主观:在初始业务核心模块的开发时,使用的就是先更新数据库,后删除缓存,并且通过异步的方式提高性能。在完成整体项目开发后的性能优化阶段,就想尝试更多的缓存一致性同步策略,因为延迟双删和旁路更新区别不大,而Canal监听性能很高,所以就优化为了Canal+MQ。
##### 客观优势
1. Canal+MQ相比于先更新数据库,后更新缓存,保证了数据的**最终强一致性**,而先删除数据库后更新缓存在高并发的环境下,易发生缓存覆盖导致数据不一致问题。
2. Canal通过伪装成从库,实现**无侵入式**的缓存更新策略。而先删除数据库后更新缓存会将更新缓存代码和业务代码强耦合。
3. Canal**性能更高**,通过异步监听+异步发送接收+削峰填谷可以保证系统高可用和高性能。而先删除数据库后更新缓存性能不如Canal。
4. Canal通过消息队列可以支持**更强的容错机制**,可以通过重试机制+死信队列保证消息不丢失;通过顺序队列保证消息顺序提交。
##### 客观劣势
* 引入Canal和MQ**维护成本更高**,系统复杂度增加。
#### Canal和延迟双删除对比
1. 数据一致性:延迟双删依赖第二次删除缓存确保数据最终一致性,如果第二次删除过早**可能导致数据不一致,而且不易发觉**。
2. 代码耦合:延迟双删需要在业务层手动实现。
3. 由于延迟双删要进行两次删除,所以性能也不如Canal。

## 题库模块
1. 建立题目题库**关联表**,便于通过题目定位题库,使用题库检索题目。避免对于题目表,题库表的全表扫描查询数据,减少了性能损耗。
2. 基于自定义线程池+ComputableFuture+异步实现题目题库关联的批量修改,避免业务阻塞,提高了系统性能。

## 帖子模块
### Redis为核心+MQ异步同步方案选型
1. 从MySQL作为操作核心转化为Redis作为操作核心,将MySQL作为一个仅持久化的数据库,**最大程度保证了数据库的安全性和可用性**,减少了数据库因为大量数据请求的崩溃问题。
2. 通过RocketMQ实现数据的异步持久化,通过消息队列保证数据的传输可靠性。
3. 设置**重试机制+死信队列实现消息的重试和补偿**。
4. 通过**状态机和数据库唯一索引**实现消息的幂等性处理。
* 以下为点赞系统流程图:
![无标题-2025-05-05-1146 8](https://github.com/user-attachments/assets/cd5ee759-ff10-40d8-b5c2-705f0cf9847a)

#### 对于消息丢失的问题处理
* 因为本点赞模块强依赖于Redis的可靠性,通过Redis的持久化机制可最大程度避免在Redis的信息丢失问题。
* 在消息队列传递消息过程中,通过**最大程度重试机制+死信队列**全力保证数据不丢失。
#### 对于消息顺序性问题的处理
* 本项目的持久化实体(ThumbEvent)中携带了在Redis操作时的**时间信息**(Date),并且封装到ThumbEvent中。
##### 对于消息传递的顺序性
* 本项目使用了**顺序队列**来处理消息发送,在不出意外的情况下,是不用检查Date属性就可以保证数据顺序持久化到数据库的。
* 当然也会有意外情况,当数据传递失败时。会加入到本地的ConcurrentLinkedQueue中,使用**队列尽量保证重试消息的顺序性**。这时就会有人问了:帅鸽,你重试队列虽然顺序了,但是对于同一批处理的消息你已经不是顺序了,这怎么解决?别急,在持久化时仍然会进行顺序性校验。
##### 对于消息持久化到数据库的顺序性问题的处理
* 在数据库的Thumb表中,存在updateTime字段,用于记录最新的更新时间。
* 在ThumbEvent持久化到数据库时,会**对比ThumbEvent中的Date字段和要修改数据的updateTime字段**,如果Date在updateTime之后,就表明是最新数据,可以更新;否则,表明该更新数据是脏数据,如果插入会导致数据错误,应该丢弃。这样就充分保证了消息处理的顺序性。虽然会有性能的损失,但是消息的持久化变得更安全可靠。
#### 对于消息重复性问题的处理
* 在ThumbEvent字段中设置了**Status状态值**,当成功发送到消费者后,设置为true,表明消息传递成功。
* 消息的重复性问题也通过**比较Date和updateTime**来处理。
#### 使用Redis为核心和MySQL的原因
##### 优势
* **高性能**:Redis基于内存操作,读写速度远高于MySQL。
* 可以**削峰填谷**:可以通过MQ将流量平摊到各个时间段,避免MySQL承受高峰流量操作。
* 降低MySQL负载:可以通过结合连接池,降低MySQL的IO压力和锁竞争。
##### 劣势
* 会导致**数据短暂不一致**,但是会达到最终一致性。
* Redis持久化机制在**极端情况下可能丢失数据**。
* 会导致跨Redis和MySQL的**事务**,需要结合分布式事务方案补偿。
## 模拟面试模块
1. 基于LangChain4J框架+DashScope实现**对话记忆**和**临时对话存储**。
2. 通过DashScope的**多模态模型的图像识别**,实现真实的基于简历面试和简历的针对性优化意见,提高了用户的体验感和面试的真实性。
3. 通过建立**自纠错RAG(Currective-RAG)**,当用户请求传入时,先进行本地RAG检索增强,将生成的Context和UserPrompt传入大模型生成。得到结果后,进行词检索和逻辑检索。通过后返回结果。
4. 将原本的内存向量库优化为**PgVector向量库**,避免的每次启动都要将文本向量化加载进内存向量库。可以通过PgVector建立索引实现高效的查询检索。
5. 将返回的SystemPrompt进行格式纠正和规范化,去除markDown格式中不必要的符号,返回String字符串。 
### 对于使用C-RAG的技术选型
* 原因:因为针对于模拟面试这个业务模块,面试题的**专业性和回答的准确性需求是P0级别**。所以要先保证面试的专业性和正确性,C-RAG实现了"检索-生成-验证-纠正"的闭环逻辑,最大程度保证了专业性和正确性的需求。
#### 选择C-RAG而不是Agents智能体
* 因为本业务中的核心只有保证回答的正确专业。 而Agents的核心是**智能决策,统一调度**,对于拥有的工具根据用户的请求,进行选择调度,利用所拥有的资源(Tools,RAG,MCP等)实现最优回答。 在本项目中,不需要创建Tools辅助,也不需要远程调用MCP,只需要使用RAG。 如果搭建Agents会**增加系统复杂度对于业务实现并没有明显提高**,所以只对RAG进行的增强搭建。
#### 选择C-RAG而不是其他RAG
* C-RAG的核心优势在于回答自检,**适合于对回答准确性专业性要求极高的业务场景**。自省式RAG(Self-RAG)只要服务于提升系统效率,对于简单任务不进行RAG检索,直接使用模型解决。检索树RAG(RAPTOR)主要服务于复杂任务的拆分处理,将多个子任务分别检索增强后调用模型输出。很显然,对于问答型的模拟面试业务,C-RAG是最好的选择。

### 对于向量存储的技术选型
* 在模拟面试模块初始实现的时候是通过内存向量库来存储向量。在功能完成后,因为基于内存的向量数据库会重启丢失数据并且无法存储大量数据,所以就引入PgVector向量数据库来替换内存向量库。
#### PgVector向量库的优势
1. 支持ACID事务和**持久化存储**。
2. 有很**高的扩展性**,可以搭建分布式向量库。
3. 支持多种检索方式,比如全文检索等。
#### PgVector向量库的劣势
1. 在超大规模向量检索或者高并发检索时会**产生性能瓶颈**,可以通过使用分布式向量数据库解决。
2. 存储和计算资源消耗大。
#### 内存向量库的优势
1. 直接操作内存,可以实现快速响应。
2. 配置简单。

# 运行示例:
![PixPin_2025-05-05_16-42-25](https://github.com/user-attachments/assets/259af430-130d-4485-b6d3-33239ef8c890)
![PixPin_2025-05-05_16-43-23](https://github.com/user-attachments/assets/1234c37c-c4f0-4e15-8ed8-126c65fd2684)
![PixPin_2025-05-05_16-43-58](https://github.com/user-attachments/assets/295ee031-2a9d-49bc-bd57-b96e21907da1)
![PixPin_2025-05-05_16-47-04](https://github.com/user-attachments/assets/89cd3e63-7abf-4073-9c08-b310b5bef507)
![PixPin_2025-05-09_23-05-03](https://github.com/user-attachments/assets/b5c11da7-c06b-4da9-8d24-7f0af411c81d)
